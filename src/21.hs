import Aoc
import Data.Function
import Data.List
import Data.List.Split
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe

input = "../.. => .../#.#/...\n#./.. => ..#/..#/#..\n##/.. => .../#../..#\n.#/#. => #../.../...\n##/#. => #.#/.#./#..\n##/## => ..#/#.#/..#\n.../.../... => .#../#..#/#.../.#..\n#../.../... => ..##/..##/.#.#/....\n.#./.../... => ..##/..##/.###/##..\n##./.../... => ..../.##./#.##/..#.\n#.#/.../... => ####/#.##/#.##/#.#.\n###/.../... => #..#/..#./..../##.#\n.#./#../... => ..#./.#../...#/#.##\n##./#../... => ..../#.##/#..#/.#..\n..#/#../... => ##.#/####/###./###.\n#.#/#../... => ..../#.##/.###/#.#.\n.##/#../... => ..#./##.#/####/..##\n###/#../... => ..#./.##./...#/..#.\n.../.#./... => .###/#.../.#../####\n#../.#./... => ###./.#.#/#.##/##.#\n.#./.#./... => ..##/..#./###./..#.\n##./.#./... => #..#/..#./###./...#\n#.#/.#./... => #.../##.#/#.##/#..#\n###/.#./... => ...#/#..#/####/##.#\n.#./##./... => #.##/#.##/..../#.#.\n##./##./... => ..##/###./..#./####\n..#/##./... => ..../##../##.#/.##.\n#.#/##./... => ##../####/####/.#.#\n.##/##./... => ..../##.#/.###/##..\n###/##./... => .#../#.#./.#../..##\n.../#.#/... => ####/#.#./..##/#..#\n#../#.#/... => .#../.#../#..#/....\n.#./#.#/... => ..##/.##./####/#.#.\n##./#.#/... => ..#./###./.#../....\n#.#/#.#/... => ..#./..#./...#/#...\n###/#.#/... => ###./.#../##../####\n.../###/... => #.##/####/####/..##\n#../###/... => .#.#/...#/###./...#\n.#./###/... => ..../.#.#/.#../....\n##./###/... => ...#/.###/..../.##.\n#.#/###/... => ..##/###./.#../#..#\n###/###/... => .###/..#./..#./.###\n..#/.../#.. => .##./###./####/#.#.\n#.#/.../#.. => ####/#.../#.../..##\n.##/.../#.. => ###./#..#/..#./.#..\n###/.../#.. => .###/.##./#.#./.###\n.##/#../#.. => ##.#/...#/.#.#/...#\n###/#../#.. => #.##/..#./..../#..#\n..#/.#./#.. => #..#/##.#/.##./####\n#.#/.#./#.. => ###./..##/#..#/#..#\n.##/.#./#.. => .#../..../...#/...#\n###/.#./#.. => .#../##../.###/..#.\n.##/##./#.. => ##../..##/##../##.#\n###/##./#.. => #.##/#..#/.###/####\n#../..#/#.. => ##.#/####/#.../..##\n.#./..#/#.. => #..#/..../..../###.\n##./..#/#.. => #..#/##.#/##.#/#.#.\n#.#/..#/#.. => .###/##.#/####/#...\n.##/..#/#.. => ####/.##./...#/#..#\n###/..#/#.. => .#.#/####/##.#/...#\n#../#.#/#.. => ..##/.##./..##/##..\n.#./#.#/#.. => #.../##../..##/..#.\n##./#.#/#.. => ...#/##.#/#..#/.#..\n..#/#.#/#.. => #.#./##../#.##/###.\n#.#/#.#/#.. => ##../##.#/#.#./....\n.##/#.#/#.. => ####/...#/####/.#..\n###/#.#/#.. => ..../.#../.#../....\n#../.##/#.. => .#.#/..#./#..#/.###\n.#./.##/#.. => #.../.#.#/.###/.##.\n##./.##/#.. => #.#./#.#./.#../###.\n#.#/.##/#.. => ####/##../.##./####\n.##/.##/#.. => #.../#.#./#.##/###.\n###/.##/#.. => ####/####/..../####\n#../###/#.. => ####/.##./...#/##.#\n.#./###/#.. => .#../#.##/#..#/..##\n##./###/#.. => #.#./..##/#.../..##\n..#/###/#.. => #.##/.###/#.#./###.\n#.#/###/#.. => #.##/#.##/..../#..#\n.##/###/#.. => .##./#.#./..##/####\n###/###/#.. => .##./#..#/#.../###.\n.#./#.#/.#. => #.#./#..#/#..#/##.#\n##./#.#/.#. => ...#/#.#./##.#/###.\n#.#/#.#/.#. => ##.#/..##/##.#/#.##\n###/#.#/.#. => .#.#/..#./##../.##.\n.#./###/.#. => #..#/..#./..##/#...\n##./###/.#. => ####/.#.#/####/..#.\n#.#/###/.#. => #.#./..##/##../#..#\n###/###/.#. => ...#/..../..../#.#.\n#.#/..#/##. => ..#./.##./###./.#.#\n###/..#/##. => #.../###./...#/####\n.##/#.#/##. => ..../..../.###/##..\n###/#.#/##. => ##../..../#.#./.##.\n#.#/.##/##. => .#.#/##../..##/#.#.\n###/.##/##. => ###./####/...#/.#..\n.##/###/##. => ..##/#.../..##/.#.#\n###/###/##. => ..##/...#/.###/.#..\n#.#/.../#.# => ..##/#.../##.#/....\n###/.../#.# => #.##/#..#/..../##..\n###/#../#.# => #.../..../##.#/..#.\n#.#/.#./#.# => ###./..##/.#../.##.\n###/.#./#.# => ..../#..#/.###/#..#\n###/##./#.# => .#.#/###./##.#/.###\n#.#/#.#/#.# => ..../..../.##./#..#\n###/#.#/#.# => .###/.#.#/...#/.###\n#.#/###/#.# => .#.#/##../.#../.#..\n###/###/#.# => .#.#/.##./#.##/....\n###/#.#/### => ..#./..#./..#./..##\n###/###/### => ##.#/..##/.#.#/...."

type Grid = [String]

parseInput :: String -> Map Grid Grid
parseInput s = lines s & concatMap parseLine & Map.fromList
  where
    parseLine s = case splitOn " => " s & map (splitOn "/") of
      [a,b] ->
        let a1 = (reverse . transpose) a in
        let a2 = (reverse . transpose) a1 in
        let a3 = (reverse . transpose) a2 in
        [a,a1,a2,a3] & concatMap (\a -> [(a,b), (reverse a,b)])
      _ -> error "invalid input"

getMap :: Map Grid Grid -> Grid -> Grid
getMap m k = case Map.lookup k m of
  Just v -> v
  Nothing -> error ("Key not found: " ++ show k)

simulateStep :: Map Grid Grid -> Grid -> Grid
simulateStep rules grid = chunksOf size grid & concatMap mapChunk
  where
    size = if even (length grid) then 2 else 3
    mapChunk chunk = map (chunksOf size) chunk & transpose & map (getMap rules) & transpose & map concat

simulate :: Map Grid Grid -> Int -> Int
simulate rules times = concat finalGrid & filter (=='#') & length
  where finalGrid = iterate (simulateStep rules) [".#.","..#","###"] !! times

solveParts :: Int -> (Int,Int)
solveParts _ = (simulate rules 5, simulate rules 18)
  where rules = parseInput input

main = Aoc.timer solveParts
